// Auto-generated MAME ROM database for arcade_rom_pro
// Generated by generate_embedded_database.py
// DO NOT EDIT MANUALLY

#ifndef MAME_ROM_DATABASE_H
#define MAME_ROM_DATABASE_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// Database configuration
// ============================================================================

#define MRDB_MAGIC          0x4244524D  // "MRDB" in little-endian
#define MRDB_VERSION        1
#define MRDB_MIN_SIZE_POW2  11
#define MRDB_MAX_SIZE_POW2  23
#define MRDB_NUM_SIZES      13

#define MRDB_NULL_ID_24     0xFFFFFF
#define MRDB_NULL_ID_16     0xFFFF

// ============================================================================
// Database statistics
// ============================================================================

#define MRDB_ROMS_COUNT         157561
#define MRDB_MACHINES_COUNT     49537
#define MRDB_MACHINE_ROMS_COUNT 408997
#define MRDB_MANUFACTURERS_COUNT 4233
#define MRDB_ROM_NAMES_COUNT    161642
#define MRDB_TOTAL_SIZE         13157773

// ============================================================================
// Data structures
// ============================================================================

// Header structure (64 bytes)
typedef struct __attribute__((packed)) {
    uint32_t magic;
    uint16_t version;
    uint8_t min_size_pow2;
    uint8_t max_size_pow2;

    uint32_t roms_count;
    uint32_t machines_count;
    uint32_t machine_roms_count;
    uint32_t manufacturers_count;
    uint32_t rom_names_count;

    uint32_t size_index_offset;
    uint32_t roms_offset;
    uint32_t machines_offset;
    uint32_t machine_roms_offset;
    uint32_t manufacturers_offset;
    uint32_t rom_names_offset;
    uint32_t strings_offset;
    uint32_t desc_offset;
} MrdbHeader;

// Size index entry (8 bytes per size)
// Stores byte offsets relative to roms_offset for direct pointer access
typedef struct __attribute__((packed)) {
    uint32_t start_offset;    // Byte offset to first ROM of this size (relative to roms_offset)
    uint32_t end_offset;      // Byte offset past last ROM of this size (relative to roms_offset)
} MrdbSizeIndex;

// ROM entry (23 bytes)
typedef struct __attribute__((packed)) {
    uint8_t sha1[20];
    uint8_t name_id[3];       // 24-bit ID into rom_names table
} MrdbRom;

// Machine entry (17 bytes)
typedef struct __attribute__((packed)) {
    uint32_t name_offset;     // Offset into strings pool
    uint32_t desc_offset;     // Offset into descriptions pool
    uint8_t desc_length;      // Compressed description length
    uint16_t cloneof_id;      // 16-bit machine ID or 0xFFFF
    uint16_t romof_id;        // 16-bit machine ID or 0xFFFF
    uint16_t year;            // Release year (16-bit)
    uint16_t manufacturer_id; // 16-bit ID or 0xFFFF
} MrdbMachine;

// Machine-ROM mapping entry (8 bytes)
typedef struct __attribute__((packed)) {
    uint16_t machine_id;      // 16-bit machine ID
    uint8_t rom_id[3];        // 24-bit ROM ID (size_pow2 << 16 | index)
    uint8_t name_id[3];       // 24-bit ROM name ID in this machine
} MrdbMachineRom;

// Manufacturer entry (4 bytes)
typedef struct __attribute__((packed)) {
    uint32_t name_offset;     // Offset into strings pool
} MrdbManufacturer;

// ROM name entry (4 bytes)
typedef struct __attribute__((packed)) {
    uint32_t name_offset;     // Offset into strings pool
} MrdbRomName;

// ============================================================================
// Helper macros for 24-bit ID handling
// ============================================================================

#define MRDB_READ_UINT24(ptr) \
    ((uint32_t)(ptr)[0] | ((uint32_t)(ptr)[1] << 8) | ((uint32_t)(ptr)[2] << 16))

#define MRDB_WRITE_UINT24(ptr, val) do { \
    (ptr)[0] = (uint8_t)((val) & 0xFF); \
    (ptr)[1] = (uint8_t)(((val) >> 8) & 0xFF); \
    (ptr)[2] = (uint8_t)(((val) >> 16) & 0xFF); \
} while(0)

// Extract size_pow2 from ROM ID
#define MRDB_ROM_ID_SIZE_POW2(rom_id) (((rom_id) >> 16) & 0xFF)

// Extract index from ROM ID
#define MRDB_ROM_ID_INDEX(rom_id) ((rom_id) & 0xFFFF)

// Create ROM ID from size_pow2 and index
#define MRDB_MAKE_ROM_ID(size_pow2, index) (((uint32_t)(size_pow2) << 16) | (index))

// ============================================================================
// Database access functions (to be implemented)
// ============================================================================

// Get pointer to embedded database
const uint8_t* mrdb_get_data(void);

// Get database header
static inline const MrdbHeader* mrdb_get_header(const uint8_t* db) {
    return (const MrdbHeader*)db;
}

// Get size index table
static inline const MrdbSizeIndex* mrdb_get_size_index(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbSizeIndex*)(db + hdr->size_index_offset);
}

// Get ROMs table
static inline const MrdbRom* mrdb_get_roms(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbRom*)(db + hdr->roms_offset);
}

// Get machines table
static inline const MrdbMachine* mrdb_get_machines(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbMachine*)(db + hdr->machines_offset);
}

// Get machine-ROMs table
static inline const MrdbMachineRom* mrdb_get_machine_roms(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbMachineRom*)(db + hdr->machine_roms_offset);
}

// Get manufacturers table
static inline const MrdbManufacturer* mrdb_get_manufacturers(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbManufacturer*)(db + hdr->manufacturers_offset);
}

// Get ROM names table
static inline const MrdbRomName* mrdb_get_rom_names(const uint8_t* db) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const MrdbRomName*)(db + hdr->rom_names_offset);
}

// Get string from pool
static inline const char* mrdb_get_string(const uint8_t* db, uint32_t offset) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return (const char*)(db + hdr->strings_offset + offset);
}

// Get compressed description
static inline const uint8_t* mrdb_get_description(const uint8_t* db, uint32_t offset) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    return db + hdr->desc_offset + offset;
}

// ============================================================================
// ROM lookup functions
// ============================================================================

#define MRDB_ROM_ENTRY_SIZE 23  // sha1(20) + name_id(3)

/**
 * Binary search for a ROM by size and SHA1.
 *
 * @param db        Pointer to the database
 * @param size_pow2 ROM size as power of 2 (e.g., 21 for 2MB)
 * @param sha1      20-byte SHA1 hash to search for
 * @return          Pointer to matching MrdbRom entry, or NULL if not found
 */
const MrdbRom* mrdb_find_rom_by_sha1(const uint8_t* db, uint8_t size_pow2, const uint8_t* sha1);

/**
 * Get ROM ID from a ROM pointer.
 *
 * @param db  Pointer to the database
 * @param rom Pointer to the ROM entry
 * @return    24-bit ROM ID (size_pow2 << 16 | index)
 */
static inline uint32_t mrdb_get_rom_id(const uint8_t* db, const MrdbRom* rom) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    const MrdbRom* roms_base = mrdb_get_roms(db);
    uint32_t index = (uint32_t)(rom - roms_base);

    // Find size_pow2 from the size index
    const MrdbSizeIndex* size_idx = mrdb_get_size_index(db);
    for (uint8_t sp = hdr->min_size_pow2; sp <= hdr->max_size_pow2; sp++) {
        uint32_t start = size_idx[sp - hdr->min_size_pow2].start_offset / MRDB_ROM_ENTRY_SIZE;
        uint32_t end = size_idx[sp - hdr->min_size_pow2].end_offset / MRDB_ROM_ENTRY_SIZE;
        if (index >= start && index < end) {
            return MRDB_MAKE_ROM_ID(sp, index - start);
        }
    }
    return MRDB_NULL_ID_24;
}

// ============================================================================
// Machine lookup functions
// ============================================================================

#define MRDB_MACHINE_ROM_ENTRY_SIZE 8  // machine_id(2) + rom_id(3) + name_id(3)

/**
 * Result structure for machine lookup.
 */
typedef struct {
    uint32_t machine_id;       // Machine ID
    uint32_t rom_name_id;      // ROM filename ID for this machine
} MrdbMachineResult;

/**
 * Get all machines associated with a ROM.
 *
 * @param db          Pointer to the database
 * @param rom         Pointer to the ROM entry (from mrdb_find_rom_by_sha1)
 * @param size_pow2   Size of the ROM (power of 2)
 * @param results     Array to store results
 * @param max_results Maximum number of results to return
 * @return            Number of machines found (may be > max_results if truncated)
 */
uint32_t mrdb_get_machines_for_rom(const uint8_t* db, const MrdbRom* rom,
                                    uint8_t size_pow2, MrdbMachineResult* results,
                                    uint32_t max_results);

/**
 * Get machine name.
 */
const char* mrdb_get_machine_name(const uint8_t* db, uint32_t machine_id);

/**
 * Get machine description (decompresses zlib data).
 *
 * @param db          Pointer to the database
 * @param machine_id  Machine ID
 * @param buffer      Output buffer for decompressed description
 * @param buffer_size Size of output buffer
 * @return            Length of description, or 0 if failed/empty
 */
uint32_t mrdb_get_machine_description(const uint8_t* db, uint32_t machine_id,
                                       char* buffer, uint32_t buffer_size);

/**
 * Get machine cloneof ID.
 */
static inline uint16_t mrdb_get_machine_cloneof(const uint8_t* db, uint32_t machine_id) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    if (machine_id >= hdr->machines_count) {
        return MRDB_NULL_ID_16;
    }
    const MrdbMachine* machine = &mrdb_get_machines(db)[machine_id];
    return machine->cloneof_id;
}

/**
 * Get machine romof ID.
 */
static inline uint16_t mrdb_get_machine_romof(const uint8_t* db, uint32_t machine_id) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    if (machine_id >= hdr->machines_count) {
        return MRDB_NULL_ID_16;
    }
    const MrdbMachine* machine = &mrdb_get_machines(db)[machine_id];
    return machine->romof_id;
}

/**
 * Get machine year.
 */
static inline uint16_t mrdb_get_machine_year(const uint8_t* db, uint32_t machine_id) {
    const MrdbHeader* hdr = mrdb_get_header(db);
    if (machine_id >= hdr->machines_count) {
        return 0;
    }
    const MrdbMachine* machine = &mrdb_get_machines(db)[machine_id];
    return machine->year;
}

/**
 * Get ROM filename.
 */
const char* mrdb_get_rom_name(const uint8_t* db, uint32_t name_id);

#ifdef __cplusplus
}
#endif

#endif // MAME_ROM_DATABASE_H
